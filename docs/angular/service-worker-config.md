# Конфигурация работника службы

В этой теме описываются свойства файла конфигурации работника службы.

## Предварительные условия

Базовое понимание следующего:

-   [Service worker overview](https://developer.chrome.com/docs/workbox/service-worker-overview/)

-   [Service Worker in Production](guide/service-worker-devops)

Конфигурационный файл `ngsw-config.json` определяет, какие файлы и URL данных должен кэшировать сервисный работник Angular и как он должен обновлять кэшированные файлы и данные. [Angular CLI](cli) обрабатывает конфигурационный файл во время `ng build`.

Вручную, обработайте его с помощью инструмента `ngsw-config`\ (где `<имя проекта>` - имя собираемого проекта\):

<code-example format="shell" language="shell">

./node_modules/.bin/ngsw-config ./dist/&lt;project-name&gt; ./ngsw-config.json [/base/href]

</code-example>

Конфигурационный файл использует формат JSON. Все пути к файлам должны начинаться с `/`, что соответствует директории развертывания &mdash;обычно `dist/<имя проекта>` в проектах CLI.

<a id="glob-patterns"></a>

Если не указано иное, шаблоны используют **ограниченный\*** формат glob, который внутри будет преобразован в regex:

| Glob formats | Details | | :----------- | :----------------------------------------------------------------------------------------------------- | |

| `**` | Совпадает с 0 или более сегментами пути |

| `*` | Идет поиск 0 или более символов, исключая `/` |

| `?` | Сопоставляет ровно один символ, исключая `/` |

| `!` префикс | Помечает шаблон как отрицательный, что означает, что включаются только файлы, которые не соответствуют шаблону |

<div class="alert is-helpful">

**\*** Pay attention that some characters with a special meaning in a regular expression are not escaped and also the pattern is not wrapped in `^`/`$` in the internal glob to regex conversion.

-   `$` is a special character in regex that matches the end of the string and will not be automatically escaped when converting the glob pattern to a regular expression.

    If you want to literally match the `$` character, you have to escape it yourself (with `\\$`).

      <div class="alert is-important">

    For example, the glob pattern `/foo/bar/$value` results in an unmatchable expression, because it is impossible to have a string that has any characters after it has ended.

      </div>

-   The pattern will not be automatically wrapped in `^` and `$` when converting it to a regular expression.

    Therefore, the patterns will partially match the request URLs.

    If you want your patterns to match the beginning and/or end of URLs, you can add `^`/`$` yourself.

      <div class="alert is-important">

    For example, the glob pattern `/foo/bar/*.js` will match both `.js` and `.json` files.

    If you want to only match `.js` files, use `/foo/bar/*.js$`.

      </div>

</div>

Примеры шаблонов:

| Шаблоны | Детали | | :----------- | :------------------------------------ |.

| `/**/*.html` | Определяет все HTML файлы |

| `/*.html` | Определяет только HTML файлы в корне |

| `!/**/*.map` | Исключить все карты источников |

## Свойства конфигурации работника службы

В следующих разделах описывается каждое свойство конфигурационного файла.

### `appData`.

Этот раздел позволяет вам передать любые данные, которые описывают данную конкретную версию приложения. Служба `SwUpdate` включает эти данные в уведомления об обновлении.

Многие приложения используют этот раздел для предоставления дополнительной информации для отображения всплывающих окон пользовательского интерфейса, уведомляющих пользователей о доступном обновлении.

<a id="index-file"></a>

### `index`

Определяет файл, который служит в качестве индексной страницы для удовлетворения навигационных запросов. Обычно это `/index.html`.

### `assetGroups`

_Ассеты_ - это ресурсы, которые являются частью версии приложения и обновляются вместе с ним. Они могут включать ресурсы, загруженные из исходного текста страницы, а также сторонние ресурсы, загруженные из CDN и других внешних URL.

Поскольку не все такие внешние URL могут быть известны на момент сборки, можно сопоставить шаблоны URL.

<div class="alert is-important">

Чтобы работник службы мог обрабатывать ресурсы, загруженные из разных источников, убедитесь, что [CORS][mozilladeveloperdocswebhttpcors] правильно настроен на сервере каждого источника.

</div>

Это поле содержит массив групп активов, каждая из которых определяет набор ресурсов активов и политику, в соответствии с которой они кэшируются.

<code-example format="json" language="json">

{ "assetGroups": [
{

&hellip;

},

{

&hellip;

}

]

}

</code-example>

<div class="alert is-helpful">

Когда ServiceWorker обрабатывает запрос, он проверяет группы активов в том порядке, в котором они появляются в файле `ngsw-config.json`. Первая группа активов, которая соответствует запрашиваемому ресурсу, обрабатывает запрос.

Рекомендуется размещать более специфические группы активов выше в списке. Например, группа активов, соответствующая `/foo.js`, должна появляться перед группой, соответствующей `*.js`.

</div>

Каждая группа активов определяет как группу ресурсов, так и политику, которая ими управляет. Эта политика определяет, когда извлекаются ресурсы и что происходит при обнаружении изменений.

Группы активов следуют интерфейсу Typescript, показанному здесь:

<code-example format="typescript" language="typescript">

интерфейс AssetGroup { name: string;
installMode?: 'prefetch' | 'lazy';

updateMode?: 'prefetch' | 'lazy';

ресурсы: {

файлы?: string[];

urls?: string[];

};

cacheQueryOptions? {

ignoreSearch?: boolean;

};

}

</code-example>

Каждая `AssetGroup` определяется следующими свойствами группы активов.

#### `имя`.

Имя `name` является обязательным. Оно идентифицирует данную конкретную группу активов между версиями конфигурации.

#### `installMode`.

Свойство `installMode` определяет способ первоначального кэширования этих ресурсов. Значение `installMode` может быть одним из двух:

| Values | Details | | :--------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

| `prefetch` | Приказывает работнику сервиса Angular получить все перечисленные ресурсы, пока он кэширует текущую версию приложения. Это требует большой пропускной способности, но обеспечивает доступность ресурсов при каждом запросе, даже если браузер в данный момент находится в автономном режиме. |

| `lazy` | Не кэширует ни один из ресурсов заранее. Вместо этого работник службы Angular кэширует только те ресурсы, к которым он получает запросы. Это режим кэширования по требованию. Ресурсы, которые никогда не запрашиваются, не кэшируются. Это полезно для таких вещей, как изображения с разным разрешением, так что работник сервиса кэширует только те ресурсы, которые подходят для конкретного экрана и ориентации. |

По умолчанию используется `prefetch`.

#### `updateMode`

Для ресурсов, уже находящихся в кэше, параметр `updateMode` определяет поведение кэша при обнаружении новой версии приложения. Любые ресурсы в группе, которые изменились с предыдущей версии, обновляются в соответствии с `updateMode`.

| Значения | Подробности | | :--------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------.

| `prefetch` | Приказывает работнику службы немедленно загрузить и кэшировать измененные ресурсы. |

| `lazy` | Приказывает работнику службы не кэшировать эти ресурсы. Вместо этого он рассматривает их как незапрошенные и ждет, пока они не будут запрошены снова, прежде чем обновлять их. Режим обновления `lazy` действителен только в том случае, если режим установки `installMode` также `lazy`. |

По умолчанию принимает значение, на которое установлен `installMode`.

#### `ресурсы`.

В этом разделе описываются ресурсы для кэширования, разбитые на следующие группы:

| Resource groups | Details | | :-------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `files` | Lists patterns that match files in the distribution directory. These can be single files or glob-like patterns that match a number of files. |

| `urls` | Includes both URLs and URL patterns that are matched at runtime. These resources are not fetched directly and do not have content hashes, but they are cached according to their HTTP headers. This is most useful for CDNs such as the Google Fonts service. <br /> _\(Negative glob patterns are not supported and `?` will be matched literally; that is, it will not match any character other than `?`.\)_ |

#### `cacheQueryOptions`

These options are used to modify the matching behavior of requests. They are passed to the browsers `Cache#match` function.

See [MDN](https://developer.mozilla.org/docs/Web/API/Cache/match) for details.

Currently, only the following options are supported:

| Options | Details | | :------------- | :-------------------------------------------- | |
| `ignoreSearch` | Игнорировать параметры запроса. По умолчанию `false`. |

### `dataGroups`

В отличие от ресурсов активов, запросы данных не версионируются вместе с приложением. Они кэшируются в соответствии с настроенными вручную политиками, которые более полезны для таких ситуаций, как API-запросы и другие зависимости данных.

Это поле содержит массив групп данных, каждая из которых определяет набор ресурсов данных и политику, в соответствии с которой они кэшируются.

<code-example format="json" language="json">

{ "dataGroups": [
{

&hellip;

},

{

&hellip;

}

]

}

</code-example>

<div class="alert is-helpful">

Когда ServiceWorker обрабатывает запрос, он проверяет группы данных в том порядке, в котором они появляются в файле `ngsw-config.json`. Первая группа данных, которая соответствует запрашиваемому ресурсу, обрабатывает запрос.

Рекомендуется размещать более специфические группы данных выше в списке. Например, группа данных, соответствующая `/api/foo.json`, должна появляться перед группой данных, соответствующей `/api/*.json`.

</div>

Группы данных следуют этому интерфейсу Typescript:

<code-example format="typescript" language="typescript">

export interface DataGroup { name: string;
url: string[];

версия: число

cacheConfig: {

maxSize: число;

maxAge: string;

таймаут?: строка;

стратегия?: 'свежесть' &verbar; 'производительность';

};

cacheQueryOptions? {

ignoreSearch?: boolean;

};

}

</code-example>

Каждая `Группа данных` определяется следующими свойствами группы данных.

#### `имя`.

Подобно `assetGroups`, каждая группа данных имеет `name`, которое уникально идентифицирует ее.

#### `urls`.

Список шаблонов URL. URL, соответствующие этим шаблонам, кэшируются в соответствии с политикой этой группы данных.

Кэшируются только не мутирующие запросы\(GET и HEAD\).

-   Отрицательные шаблоны glob не поддерживаются

-   `?` используется буквально, то есть соответствует _только_ символу `?`.

#### `version`.

Иногда API меняют формат таким образом, что это не приводит к обратной совместимости. Новая версия приложения может быть несовместима со старым форматом API и, следовательно, несовместима с существующими кэшированными ресурсами этого API.

`version` предоставляет механизм для указания того, что кэшируемые ресурсы были обновлены обратно несовместимым способом, и что старые записи кэша &mdash;от предыдущих версий&mdash; должны быть отброшены.

Поле `version` является целочисленным и по умолчанию равно `1`.

#### `cacheConfig`.

Следующие свойства определяют политику кэширования соответствующих запросов.

##### `maxSize`

**Обязательно**

Максимальное количество записей, или ответов, в кэше. Неограниченные кэши могут расти неограниченно и в конечном итоге превысить квоты хранения, что приведет к необходимости выселения.

##### `maxAge`

**Необходимо**

Параметр `maxAge` указывает, как долго ответы могут находиться в кэше, прежде чем будут признаны недействительными и вытеснены. `maxAge` - это строка длительности, использующая следующие суффиксы единиц измерения:

| Суффиксы | Детали | | :------- | :----------- |.

| `d` | Дни |

| `h` | Часы |

| `m` | Минуты |

| `s` | Секунды |

| `u` | Миллисекунды |.

Например, строка `3d12h` кэширует содержимое на срок до трех с половиной дней.

##### `timeout`

Эта строка duration задает таймаут сети. Таймаут сети - это время, в течение которого работник службы Angular ожидает ответа сети, прежде чем использовать кэшированный ответ, если он настроен.
`timeout` - это строка длительности, использующая следующие суффиксы единиц измерения:

| Суффиксы | Детали | | :------- | :----------- |.

| `d` | Дни |

| `h` | Часы |

| `m` | Минуты |

| `s` | Секунды |

| `u` | Миллисекунды |.

Например, строка `5s30u` означает 5 секунд и 30 миллисекунд сетевого тайм-аута.

##### `strategy`.

Angular service worker может использовать одну из двух стратегий кэширования для ресурсов данных.

| Caching strategies | Details | | :----------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `performance` | По умолчанию оптимизируется для максимально быстрых ответов. Если ресурс существует в кэше, используется кэшированная версия, и запрос в сеть не выполняется. Это допускает некоторую нестабильность, в зависимости от `maxAge`, в обмен на лучшую производительность. Это подходит для ресурсов, которые не часто меняются; например, изображения аватаров пользователей. |

| `freshness` | Оптимизируется под актуальность данных, преимущественно получая запрашиваемые данные из сети. Только если сеть не работает, в соответствии с `timeout`, запрос возвращается в кэш. Это полезно для ресурсов, которые часто меняются; например, остатки на счетах. |

<div class="alert is-helpful">

Вы также можете эмулировать третью стратегию, [staleWhileRevalidate](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate), которая возвращает кэшированные данные, если они доступны, но также забирает свежие данные из сети в фоновом режиме для следующего раза. Для использования этой стратегии установите `strategy` в `freshness` и `timeout` в `cacheConfig` в `0u`.

По сути, это делает следующее:

1.  Сначала попытаться получить данные из сети.

2.  Если сетевой запрос не завершается немедленно, то есть после тайм-аута в 0&nbsp;мс, игнорировать возраст кэша и вернуться к кэшированному значению.

3.  После завершения сетевого запроса обновите кэш для будущих запросов.

4.  Если ресурс не существует в кэше, все равно дождитесь сетевого запроса.

</div>

##### `cacheOpaqueResponses`.

Должен ли работник службы Angular кэшировать непрозрачные ответы или нет.

Если не указано, значение по умолчанию зависит от настроенной стратегии группы данных:

| Strategies | Details | | :------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

| Группы со стратегией `freshness` | Значение по умолчанию `true`, и работник службы кэширует непрозрачные ответы. Эти группы будут запрашивать данные каждый раз и возвращаться к кэшированному ответу только в автономном режиме или при медленной сети. Поэтому не имеет значения, кэширует ли работник сервиса ответ об ошибке. |

| Группы со стратегией `performance` | Значение по умолчанию - `false`, и работник службы не кэширует непрозрачные ответы. Эти группы будут продолжать возвращать кэшированный ответ до истечения `maxAge`, даже если ошибка была вызвана временной проблемой сети или сервера. Поэтому для работника службы было бы проблематично кэшировать ответ об ошибке. |

<div class="callout is-important">

<header>Comment on opaque responses</header>

Если вы не знакомы, [непрозрачный ответ][whatwgfetchspecconceptfilteredresponseopaque] - это специальный тип ответа, возвращаемый при запросе ресурса, который находится на другом источнике и не возвращает CORS-заголовки. Одной из характеристик непрозрачного ответа является то, что работнику службы не разрешается читать его статус, то есть он не может проверить, был ли запрос успешным или нет.
Более подробную информацию смотрите в [Введение в fetch()][googledeveloperwebupdates201503introductiontofetchresponsetypes].

Если вы не можете реализовать CORS &mdash; например, если вы не контролируете происхождение&mdash; предпочитайте использовать стратегию `freshness` для ресурсов, которые приводят к непрозрачным ответам.

</div>

#### `cacheQueryOptions`.

Подробности см. в [assetGroups](#assetgroups).

### `navigationUrls`

Этот необязательный раздел позволяет указать пользовательский список URL, которые будут перенаправлены в индексный файл.

#### Обработка навигационных запросов

ServiceWorker перенаправляет навигационные запросы, которые не соответствуют какой-либо группе `asset` или `data`, в указанный [индексный файл] (#index-file). Запрос считается навигационным, если:

-   Его [метод](https://developer.mozilla.org/docs/Web/API/Request/method) - `GET`.

-   Его [режим](https://developer.mozilla.org/docs/Web/API/Request/mode) - `навигационный`.

-   Он принимает ответ `text/html`, что определяется значением заголовка `Accept`.

-   Его URL соответствует следующим критериям:

    -   URL не должен содержать расширение файла \(то есть, `.`\) в последнем сегменте пути.

    -   URL не должен содержать `__`

<div class="alert is-helpful">

Чтобы настроить, будут ли навигационные запросы передаваться в сеть или нет, смотрите раздел [navigationRequestStrategy](#navigation-request-strategy).

</div>

#### Соответствие URL-адресов навигационных запросов

Хотя эти критерии по умолчанию подходят в большинстве случаев, иногда желательно настроить другие правила. Например, вы можете захотеть игнорировать определенные маршруты, например, те, которые не являются частью приложения Angular, и передавать их серверу.

Это поле содержит массив URL-адресов и [glob-like](#glob-patterns) шаблонов URL, которые будут сопоставляться во время выполнения. Он может содержать как отрицательные шаблоны \(то есть шаблоны, начинающиеся с `!`\), так и неотрицательные шаблоны и URL.

Навигационными считаются только те запросы, URL которых соответствуют _любому_ из неотрицательных URL/шаблонов и _ни одному_ из отрицательных. Запрос URL игнорируется при сопоставлении.

Если поле опущено, оно используется по умолчанию:

<code-example format="typescript" language="typescript">

[ '/\*\*', // Включить все URL-адреса.
'!/\*\*/\*.\*', // Исключить URL-адреса файлов.

'!/\*\*/\***\*', // Исключить URL, содержащие &grave;**&grave; в последнем сегменте.

'!/\*\*/\***\*/\*\*', // Исключить URL, содержащие &grave;**&grave; в любом другом сегменте.

]

</code-example>

<a id="navigation-request-strategy"></a>

### `navigationRequestStrategy`.

Это необязательное свойство позволяет вам настроить, как работник службы обрабатывает навигационные запросы:

<code-example format="json" language="json">

{ "navigationRequestStrategy": "свежесть"
}

</code-example>

| Possible values | Details | | :-------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `'performance'` | The default setting. Serves the specified [index file](#index-file), which is typically cached. |
| `'freshness'` | Passes the requests through to the network and falls back to the `performance` behavior when offline. This value is useful when the server redirects the navigation requests elsewhere using a `3xx` HTTP redirect status code. Reasons for using this value include: <ul> <li> Redirecting to an authentication website when authentication is not handled by the application </li> <li> Redirecting specific URLs to avoid breaking existing links/bookmarks after a website redesign </li> <li> Redirecting to a different website, such as a server-status page, while a page is temporarily down </li> </ul> |

<div class="alert is-important">

Стратегия `свежести` обычно приводит к увеличению количества запросов, отправляемых на сервер, что может увеличить задержку ответа. Рекомендуется использовать стратегию производительности по умолчанию, когда это возможно.

</div>

<!-- links -->

<!-- external links -->

[googledeveloperwebupdates201503introductiontofetchresponsetypes]: https://developers.google.com/web/updates/2015/03/introduction-to-fetch#response_types
[whatwgfetchspecconceptfilteredresponseopaque]: https://fetch.spec.whatwg.org#concept-filtered-response-opaque
[mozilladeveloperdocswebhttpcors]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

<!-- end links -->

:date: 28.02.2022
