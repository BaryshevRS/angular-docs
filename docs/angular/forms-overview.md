# Введение в формы в Angular

Обработка пользовательского ввода с помощью форм является краеугольным камнем многих распространенных приложений. Приложения используют формы для того, чтобы пользователи могли войти в систему, обновить профиль, ввести конфиденциальную информацию и выполнить множество других задач по вводу данных.

Angular предлагает два различных подхода к обработке пользовательского ввода с помощью форм: реактивный и основанный на шаблонах. Оба они перехватывают события пользовательского ввода из представления, проверяют пользовательский ввод, создают модель формы и модель данных для обновления и предоставляют способ отслеживания изменений.

Это руководство содержит информацию, которая поможет вам решить, какой тип формы лучше всего подходит для вашей ситуации. В нем представлены общие строительные блоки, используемые в обоих подходах.

В нем также обобщены ключевые различия между двумя подходами и продемонстрированы эти различия в контексте настройки, потока данных и тестирования.

## Предварительные условия

Это руководство предполагает, что у вас есть базовое понимание следующего.

-   [TypeScript] (https://www.typescriptlang.org/ 'The TypeScript language') и программирования HTML5.

-   Основы проектирования приложений Angular, как описано в [Концепции Angular](руководство/архитектура 'Введение в концепции Angular')

-   Основы [синтаксиса шаблонов Angular](guide/architecture-components#template-syntax 'Введение в синтаксис шаблонов')

## Выбор подхода

Реактивные формы и формы на основе шаблонов по-разному обрабатывают и управляют данными формы. Каждый подход предлагает свои преимущества.

| Forms | Details | | :-------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Реактивные формы | Обеспечивают прямой, явный доступ к объектной модели формы. По сравнению с формами, управляемыми шаблонами, они более надежны: они более масштабируемы, многократно используемы и тестируемы. Если формы являются ключевой частью вашего приложения или вы уже используете реактивные паттерны для построения приложения, используйте реактивные формы. |

| Формы, управляемые шаблонами | Опираются на директивы в шаблоне для создания и манипулирования базовой объектной моделью. Они полезны для добавления простой формы в приложение, например, формы подписки на список адресов электронной почты. Их легко добавить в приложение, но они не так хорошо масштабируются, как реактивные формы. Если у вас очень простые требования к форме и логика, которой можно управлять исключительно в шаблоне, формы, управляемые шаблоном, могут быть хорошим вариантом. |

### Ключевые различия

В следующей таблице приведены основные различия между реактивными и шаблонными формами.

| | Реактивный | Управляемый шаблонами | | :------------------------------------------ | :----------------------------------- | :------------------------------ | |
| [Настройка модели формы](#setup) | Явная, созданная в классе компонента | Неявная, созданная директивами | [Настройка модели данных](#mutability-of-the-data-model).

| [Модель данных](#mutability-of-the-data-model)| Структурированная и неизменяемая | Неструктурированная и изменяемая |

| [Поток данных](#data-flow-in-forms) | Синхронный | Асинхронный |

| [Валидация формы](#validation) | Функции | директивы |

### Масштабируемость

Если формы являются центральной частью вашего приложения, масштабируемость очень важна. Возможность повторного использования моделей форм в разных компонентах очень важна.

Реактивные формы более масштабируемы, чем формы, управляемые шаблонами. Они предоставляют прямой доступ к базовому API формы и используют [синхронный поток данных](#data-flow-in-reactive-forms) между представлением и моделью данных, что упрощает создание крупномасштабных форм.

Реактивные формы требуют меньше настроек для тестирования, а тестирование не требует глубокого понимания обнаружения изменений для правильного тестирования обновления и проверки формы.

Формы на основе шаблонов ориентированы на простые сценарии и не так удобны для повторного использования. Они абстрагируются от базового API формы и используют [асинхронный поток данных](#data-flow-in-template-driven-forms) между представлением и моделью данных.

Абстракция форм, управляемых шаблонами, также влияет на тестирование.

Тесты в значительной степени зависят от ручного выполнения обнаружения изменений, чтобы работать правильно, и требуют больше настроек.

<a id="setup"></a>

## Настройка модели формы

Как реактивные, так и шаблонные формы отслеживают изменения значений между элементами ввода формы, с которыми взаимодействуют пользователи, и данными формы в вашей компонентной модели. Эти два подхода имеют общие базовые блоки, но отличаются тем, как вы создаете и управляете общими экземплярами элементов управления формы.

### Общие классы основы формы

Как реактивные, так и шаблонные формы строятся на следующих базовых классах.

| Базовые классы | Детали | | :--------------------- | :---------------------------------------------------------------------------------- |.

| `FormControl` | Отслеживает значение и статус проверки отдельного элемента управления формы. |

| `FormGroup` | Отслеживает те же значения и статус для коллекции элементов управления формы. |

| | `FormArray` | Отслеживает те же значения и статус для массива элементов управления формы. |

| | `ControlValueAccessor` | Создает мост между экземплярами Angular `FormControl` и встроенными элементами DOM. |

<a id="setup-the-form-model"></a>

### Установка в реактивных формах

В реактивных формах вы определяете модель формы непосредственно в классе компонента. Директива `[formControl]` связывает явно созданный экземпляр `FormControl` с конкретным элементом формы в представлении, используя внутренний аксессор значения.

Следующий компонент реализует поле ввода для одного элемента управления, используя реактивные формы. В этом примере моделью формы является экземпляр `FormControl`.

<code-example path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.ts"></code-example>.

Рисунок 1 показывает, как в реактивных формах модель формы является источником истины; она предоставляет значение и статус элемента формы в любой момент времени через директиву `[formControl]` на элементе ввода.

<!--todo: make consistent with other topics -->

**Рисунок 1.** _Прямой доступ к модели формы в реактивной форме._

<div class="lightbox">

<img alt="Reactive forms key differences" src="generated/images/guide/forms-overview/key-diff-reactive-forms.png">

</div>

### Настройка в формах, управляемых шаблонами

В формах, управляемых шаблонами, модель формы является неявной, а не явной. Директива `NgModel` создает и управляет экземпляром `FormControl` для данного элемента формы.

Следующий компонент реализует одно и то же поле ввода для одного элемента управления, используя формы, основанные на шаблонах.

<code-example path="forms-overview/src/app/template/favorite-color/favorite-color.component.ts"></code-example>.

В форме, управляемой шаблоном, источником истины является шаблон. У вас нет прямого программного доступа к экземпляру `FormControl`, как показано на рисунке 2.

<!--todo: make consistent with other topics -->

**Рисунок 2.** _Прямой доступ к модели формы в форме, управляемой шаблоном._

<div class="lightbox">

<img alt="Template-driven forms key differences" src="generated/images/guide/forms-overview/key-diff-td-forms.png">

</div>

<a id="data-flow-in-forms"></a>

## Поток данных в формах

Когда приложение содержит форму, Angular должен синхронизировать представление с моделью компонентов, а модель компонентов - с представлением. Когда пользователи изменяют значения и делают выбор через представление, новые значения должны быть отражены в модели данных.

Аналогично, когда программная логика изменяет значения в модели данных, эти значения должны быть отражены в представлении.

Реактивные и шаблонные формы отличаются тем, как они обрабатывают данные, поступающие от пользователя или от программных изменений. Следующие диаграммы иллюстрируют оба вида потока данных для каждого типа формы, используя поле ввода "любимый цвет", определенное выше.

<a id="data-flow-in-reactive-forms"></a>

### Поток данных в реактивных формах

В реактивных формах каждый элемент формы в представлении напрямую связан с моделью формы\(экземпляр\ `FormControl`). Обновления от представления к модели и от модели к представлению синхронны и не зависят от того, как отображается пользовательский интерфейс.

Диаграмма "представление - модель" показывает, как происходит движение данных при изменении значения поля ввода из представления посредством следующих шагов.

1.  Пользователь вводит значение в элемент ввода, в данном случае любимый цвет _Синий_.

1.  Элемент ввода формы выдает событие "input" с последним значением.

1.  Аксессор значения элемента управления, прослушивающий события на элементе ввода формы, немедленно передает новое значение экземпляру `FormControl`.

1.  Экземпляр `FormControl` передает новое значение через наблюдаемую `valueChanges`.

1.  Все подписчики наблюдаемой `valueChanges` получают новое значение.

<div class="lightbox">

<img alt="Reactive forms data flow - view to model" src="generated/images/guide/forms-overview/dataflow-reactive-forms-vtm.png">

</div>

Диаграмма "модель - представление" показывает, как программное изменение в модели распространяется на представление посредством следующих шагов.

1.  Пользователь вызывает метод `favoriteColorControl.setValue()`, который обновляет значение `FormControl`.

1.  Экземпляр `FormControl` передает новое значение через наблюдаемую `valueChanges`.

1.  Все подписчики наблюдаемой `valueChanges` получают новое значение.

1.  Аксессор значения элемента управления на элементе ввода формы обновляет элемент новым значением.

<div class="lightbox">

<img alt="Reactive forms data flow - model to view" src="generated/images/guide/forms-overview/dataflow-reactive-forms-mtv.png">

</div>

<a id="data-flow-in-template-driven-forms"></a>

### Поток данных в формах, управляемых шаблонами

В формах, управляемых шаблонами, каждый элемент формы связан с директивой, которая управляет моделью формы.

Диаграмма "представление - модель" показывает, как происходит движение данных при изменении значения поля ввода из представления посредством следующих шагов.

1.  Пользователь вводит _Синий_ в элемент ввода.

1.  Элемент ввода испускает событие "input" со значением _Blue_.

1.  Аксессор значения элемента управления, присоединенный к вводу, вызывает метод `setValue()` на экземпляре `FormControl`.

1.  Экземпляр `FormControl` передает новое значение через наблюдаемую `valueChanges`.

1.  Все подписчики наблюдаемой `valueChanges` получают новое значение.

1.  Аксессор значения элемента управления также вызывает метод `NgModel.viewToModelUpdate()`, который испускает событие `ngModelChange`.

1.  Поскольку шаблон компонента использует двустороннее связывание данных для свойства `favoriteColor`, свойство `favoriteColor` в компоненте обновляется до значения, выдаваемого событием `ngModelChange` \(_Blue_\).

<div class="lightbox">

<img alt="Template-driven forms data flow - view to model" width="100%" src="generated/images/guide/forms-overview/dataflow-td-forms-vtm.png">

</div>

Диаграмма модель-вид показывает, как данные перетекают из модели в представление, когда `favoriteColor` меняется с _Blue_ на _Red_, посредством следующих шагов

1.  Значение `favoriteColor` обновляется в компоненте.

1.  Начинается обнаружение изменений.

1.  Во время обнаружения изменений вызывается хук жизненного цикла `ngOnChanges` на экземпляре директивы `NgModel`, поскольку значение одного из ее входов изменилось.

1.  Метод `ngOnChanges()` ставит в очередь асинхронную задачу для установки значения для внутреннего экземпляра `FormControl`.

1.  Обнаружение изменений завершается.

1.  На следующем тике выполняется задача установки значения экземпляра `FormControl`.

1.  Экземпляр `FormControl` передает последнее значение через наблюдаемую `valueChanges`.

1.  Все подписчики наблюдаемой `valueChanges` получают новое значение.

1.  Аксессор значения элемента управления обновляет элемент ввода формы в представлении последним значением `favoriteColor`.

<div class="lightbox">

<img alt="Template-driven forms data flow - model to view" width="100%" src="generated/images/guide/forms-overview/dataflow-td-forms-mtv.png">

</div>

<a id="mutability-of-the-data-model"></a>

### Мутабельность модели данных

Метод отслеживания изменений играет важную роль в эффективности вашего приложения.

| Forms                 | Details                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| :-------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Reactive forms        | Keep the data model pure by providing it as an immutable data structure. Each time a change is triggered on the data model, the `FormControl` instance returns a new data model rather than updating the existing data model. This gives you the ability to track unique changes to the data model through the control's observable. Change detection is more efficient because it only needs to update on unique changes. Because data updates follow reactive patterns, you can integrate with observable operators to transform data. |
| Template-driven forms | Rely on mutability with two-way data binding to update the data model in the component as changes are made in the template. Because there are no unique changes to track on the data model when using two-way data binding, change detection is less efficient at determining when updates are required.                                                                                                                                                                                                                                 |

Разница продемонстрирована в предыдущих примерах, где используется элемент ввода favorite-color.

-   В реактивных формах экземпляр **`FormControl`** всегда возвращает новое значение, когда значение элемента управления обновляется.

-   В формах, управляемых шаблонами, свойство **favorite color** всегда изменяется на новое значение

<a id="validation"></a>

## Валидация формы

Валидация является неотъемлемой частью управления любым набором форм. Независимо от того, проверяете ли вы наличие обязательных полей или запрашиваете у внешнего API существующее имя пользователя, Angular предоставляет набор встроенных валидаторов, а также возможность создавать собственные валидаторы.

| Формы | Подробности | | :-------------------- | :----------------------------------------------------------------------------------------------------------- | |

| Реактивные формы | Определите пользовательские валидаторы как **функции**, которые получают элемент управления для проверки.

| Формы, управляемые шаблонами | Связаны с **директивами** шаблона и должны предоставлять пользовательские директивы валидаторов, которые оборачивают функции валидации.

Для получения дополнительной информации смотрите [Form Validation](guide/form-validation).

## Тестирование

Тестирование играет большую роль в сложных приложениях. Более простая стратегия тестирования полезна при проверке правильности работы ваших форм.

Реактивные формы и формы, управляемые шаблонами, имеют разные уровни зависимости от рендеринга пользовательского интерфейса для выполнения утверждений, основанных на изменениях элементов управления формы и полей формы.

Следующие примеры демонстрируют процесс тестирования форм с реактивными и управляемыми шаблонами формами.

### Тестирование реактивных форм

Реактивные формы обеспечивают относительно простую стратегию тестирования, поскольку они предоставляют синхронный доступ к модели формы и данных, и их можно тестировать без отображения пользовательского интерфейса. В этих тестах статус и данные запрашиваются и манипулируются через элемент управления без взаимодействия с циклом обнаружения изменений.

В следующих тестах используются компоненты любимого цвета из предыдущих примеров для проверки потоков данных от представления к модели и от модели к представлению для реактивной формы.

<!--todo: make consistent with other topics -->

**Проверка потока данных от представления к модели**

В первом примере выполняются следующие шаги для проверки потока данных от представления к модели.

1.  Запросите представление для элемента ввода формы и создайте пользовательское событие "ввод" для проверки.

1.  Установите новое значение для входа _Red_ и отправьте событие "input" на элемент ввода формы.

1.  Убедитесь, что значение `favoriteColorControl` компонента совпадает со значением из ввода.

<code-example header="Favorite color test - view to model" path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts" region="view-to-model"></code-example>.

В следующем примере выполняются следующие шаги для проверки потока данных от модели к представлению.

1.  Используйте `favoriteColorControl`, экземпляр `FormControl`, для установки нового значения.

1.  Запросите представление для элемента ввода формы.

1.  Убедитесь, что новое значение, установленное в элементе управления, совпадает со значением в элементе ввода.

<code-example header="Favorite color test - model to view" path="forms-overview/src/app/reactive/favorite-color/favorite-color.component.spec.ts" region="model-to-view"></code-example>

### Testing template-driven forms

Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.

The following tests use the favorite color components mentioned earlier to verify the data flows from view to model and model to view for a template-driven form.

The following test verifies the data flow from view to model.

<code-example header="Favorite color test - view to model" path="forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts" region="view-to-model"></code-example>

Here are the steps performed in the view to model test.

1.  Query the view for the form input element, and create a custom "input" event for the test.
1.  Set the new value for the input to _Red_, and dispatch the "input" event on the form input element.
1.  Run change detection through the test fixture.
1.  Assert that the component `favoriteColor` property value matches the value from the input.

The following test verifies the data flow from model to view.

<code-example header="Favorite color test - model to view" path="forms-overview/src/app/template/favorite-color/favorite-color.component.spec.ts" region="model-to-view"></code-example>

Here are the steps performed in the model to view test.

1.  Use the component instance to set the value of the `favoriteColor` property.
1.  Run change detection through the test fixture.
1.  Use the `tick()` method to simulate the passage of time within the `fakeAsync()` task.
1.  Query the view for the form input element.
1.  Assert that the input value matches the value of the `favoriteColor` property in the component instance.

## Next steps

To learn more about reactive forms, see the following guides:

-   [Reactive forms](guide/reactive-forms)
-   [Form validation](guide/form-validation#reactive-form-validation)
-   [Dynamic forms](guide/dynamic-form)

To learn more about template-driven forms, see the following guides:

-   [Building a template-driven form](guide/forms) tutorial
-   [Form validation](guide/form-validation#template-driven-validation)
-   `NgForm` directive API reference

<!-- links -->

<!-- external links -->

<!-- end links -->

:date: 28.02.2022
