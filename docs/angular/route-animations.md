# Анимация перехода между маршрутами

Маршрутизация позволяет пользователям перемещаться между различными маршрутами в приложении.

## Предварительные условия

Базовое понимание следующих концепций:

-   [Введение в анимации Angular](руководство/анимации)

-   [Переход и триггеры](руководство/переход и триггеры)

-   [Многоразовые анимации](guide/reusable-animations)

## Включить анимацию перехода маршрутизации

Когда пользователь переходит от одного маршрута к другому, маршрутизатор Angular сопоставляет путь URL с соответствующим компонентом и отображает его вид. Анимация этого перехода маршрута может значительно улучшить пользовательский опыт.

Angular router поставляется с высокоуровневыми функциями анимации, которые позволяют анимировать переходы между представлениями при изменении маршрута. Чтобы создать анимационную последовательность при переключении между маршрутами, необходимо определить вложенные анимационные последовательности.

Начните с компонента верхнего уровня, в котором расположено представление, и вложите анимацию в компоненты, в которых расположены встроенные представления.

Чтобы включить анимацию перехода между маршрутами, сделайте следующее:

1.  Импортируйте модуль маршрутизации в приложение и создайте конфигурацию маршрутизации, определяющую возможные маршруты.

1.  Добавьте выход маршрутизатора, чтобы указать маршрутизатору Angular, где разместить активированные компоненты в DOM.

1.  Определите анимацию.

Проиллюстрируйте анимацию перехода маршрутизатора, перемещаясь между двумя маршрутами, _Home_ и _About_, связанными с представлениями `HomeComponent` и `AboutComponent` соответственно. Оба эти представления компонентов являются дочерними для самого верхнего представления, расположенного в `AppComponent`.

Реализуйте анимацию перехода маршрутизатора, которая при навигации между двумя маршрутами сдвигает новый вид вправо и сдвигает старый вид.

<div class="lightbox">

<img alt="Animations in action" width="440" src="generated/images/guide/animations/route-animation.gif">

</div>

## Конфигурация маршрутов

Для начала настройте набор маршрутов, используя методы, доступные в классе `RouterModule`. Эта конфигурация маршрутов указывает маршрутизатору, как перемещаться.

Используйте метод `RouterModule.forRoot` для определения набора маршрутов. Также добавьте `RouterModule` в массив `imports` главного модуля, `AppModule`.

<div class="alert is-helpful">

**NOTE**: <br /> Use the `RouterModule.forRoot` method in the root module, `AppModule`, to register top-level application routes and providers.
For feature modules, call the `RouterModule.forChild` method instead.

</div>

Следующая конфигурация определяет возможные маршруты для приложения.

<code-example header="src/app/app.module.ts" path="animations/src/app/app/app.module.ts" region="route-animation-data"></code-example>.

Пути `home` и `about` связаны с представлениями `HomeComponent` и `AboutComponent`. Конфигурация маршрута указывает маршрутизатору Angular инстанцировать представления `HomeComponent` и `AboutComponent`, когда навигация соответствует соответствующему пути.

Свойство `data` каждого маршрута определяет ключевую конфигурацию, специфичную для анимации, связанную с маршрутом. Значение свойства `data` передается в `AppComponent` при изменении маршрута.

<div class="alert is-helpful">

**NOTE**: <br /> The `data` property names that you use can be arbitrary.
For example, the name _animation_ used in the preceding example is an arbitrary choice.

</div>

## Router outlet

После настройки маршрутов добавьте `<router-outlet>` внутри корневого шаблона `AppComponent`. Директива `<router-outlet>` указывает маршрутизатору Angular, где отображать представления при сопоставлении с маршрутом.

В `ChildrenOutletContexts` хранится информация об аутлетах и активированных маршрутах. Свойство `data` каждого `маршрута` может быть использовано для анимации переходов маршрутизации.

<code-example header="src/app/app.component.html" path="animations/src/app/app.component.html" region="route-animations-outlet"></code-example>

`AppComponent` определяет метод, который может обнаружить, когда представление изменяется. Метод присваивает значение состояния анимации триггеру анимации \(`@routeAnimation`\) на основе значения свойства `data` конфигурации маршрута.

Вот пример метода `AppComponent`, который обнаруживает изменение маршрута.

<code-example header="src/app/app.component.ts" path="animations/src/app/app.component.ts" region="get-route-animations-data"></code-example>

Метод `getRouteAnimationData()` принимает значение розетки. Он возвращает строку, которая представляет состояние анимации, основанное на пользовательских данных текущего активного маршрута. Используйте эти данные для управления тем, какой переход запускать для каждого маршрута.

## Определение анимации

Анимации могут быть определены непосредственно внутри ваших компонентов. В данном примере вы определяете анимации в отдельном файле, что позволяет повторно использовать анимации.

Следующий фрагмент кода определяет многократно используемую анимацию с именем `slideInAnimation`.

<code-example header="src/app/animations.ts" path="animations/src/app/animations.ts" region="route-animations"></code-example>.

Определение анимации выполняет следующие задачи:

-   Определяет два перехода\(один `триггер` может определять несколько состояний и переходов\)

-   Настраивает стили главного и дочернего представлений для управления их относительным положением во время перехода

-   Использует `query()` для определения того, какое дочернее представление входит, а какое выходит из главного представления.

Изменение маршрута активирует триггер анимации, и применяется переход, соответствующий изменению состояния.

<div class="alert is-helpful">

**NOTE**: <br /> The transition states must match the `data` property value defined in the route configuration.

</div>

Сделайте определение анимации доступным в вашем приложении, добавив многоразовую анимацию \(`slideInAnimation`\) в метаданные `animations` компонента `AppComponent`.

<code-example header="src/app/app.component.ts" path="animations/src/app/app/app.component.ts" region="define"></code-example>.

### Стиль главного и дочернего компонентов

Во время перехода новое представление вставляется непосредственно после старого, и оба элемента появляются на экране одновременно. Чтобы предотвратить такое поведение, обновите основное представление, чтобы оно использовало относительное позиционирование.

Затем обновите удаленные и вставленные дочерние представления, чтобы использовать абсолютное позиционирование.

Добавление этих стилей к представлениям анимирует контейнеры на месте и не позволяет одному представлению влиять на положение другого на странице.

<code-example header="src/app/animations.ts (excerpt)" path="animations/src/app/animations.ts" region="style-view"></code-example>

### Запрос контейнеров представления

Используйте метод `query()` для поиска и анимации элементов внутри текущего компонента хоста. Оператор `query(":enter")` возвращает представление, которое вставляется, а `query(":leave")` возвращает представление, которое удаляется.

Предположим, что вы выполняете маршрутизацию из раздела _Home =&gt; About_.

<code-example header="src/app/animations.ts (excerpt)" path="animations/src/app/animations.ts" region="query"></code-example>.

После стилизации представлений код анимации выполняет следующие действия:

1.  `query(':enter', style({ left: '-100%' }))` соответствует добавляемому представлению и скрывает вновь добавленное представление, позиционируя его в крайнем левом углу.

1.  Вызывает `animateChild()` на уходящем представлении, чтобы запустить его дочерние анимации.

1.  Использует функцию [`group()`](api/animations/group), чтобы внутренние анимации запускались параллельно.

1.  Внутри функции [`group()`](api/animations/group):

    1.  Запрашивает удаляемый вид и анимирует его сдвиг далеко вправо.

    1.  Вставляет новый вид, анимируя его с помощью функции смягчения и длительности.

        В результате анимации вид `about` сдвигается влево.

1.  Вызывает метод `animateChild()` нового представления, чтобы запустить его дочерние анимации после завершения основной анимации.

Теперь у вас есть базовая маршрутизируемая анимация, которая анимирует переход от одного представления к другому.

## Подробнее об анимации в Angular

Вам также может быть интересно следующее:

-   [Введение в анимации Angular](руководство/анимации)

-   [Переход и триггеры](guide/transition-and-triggers)

-   [Сложные анимационные последовательности](руководство/complex-animation-sequences)

-   [Многоразовые анимации](guide/reusable-animations)

:дата: 11.10.2022
