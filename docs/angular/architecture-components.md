---
description: Приложение Angular использует отдельные компоненты для определения и управления различными аспектами приложения
---

# Введение в компоненты и шаблоны

:date: 28.02.2022

Компонент _компонента_ управляет участком экрана, называемым _вид_. Он состоит из класса TypeScript, шаблона HTML и таблицы стилей CSS. Класс TypeScript определяет взаимодействие

шаблона HTML и отрисованной структуры DOM, а таблица стилей описывает его внешний вид.

Приложение Angular использует отдельные компоненты для определения и управления различными аспектами приложения. Например, приложение может включать компоненты для описания:

-   корень приложения с навигационными ссылками
-   Список героев
-   Редактор героев

В следующем примере класс `HeroListComponent` включает:

-   Свойство `heroes`, которое содержит массив героев.
-   Свойство `selectedHero`, которое содержит последнего героя, выбранного пользователем.
-   Метод `selectHero()` устанавливает свойство `selectedHero`, когда пользователь щелкает мышью, чтобы выбрать героя из списка.

Компонент инициализирует свойство `heroes` с помощью сервиса `HeroService`, который является TypeScript [свойством параметра](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties) на конструкторе. Система инъекции зависимостей Angular предоставляет компоненту сервис `HeroService`.

```ts
export class HeroListComponent implements OnInit {
    heroes: Hero[] = [];
    selectedHero: Hero | undefined;

    constructor(private service: HeroService) {}

    ngOnInit() {
        this.heroes = this.service.getHeroes();
    }

    selectHero(hero: Hero) {
        this.selectedHero = hero;
    }
}
```

Angular создает, обновляет и уничтожает компоненты по мере того, как пользователь перемещается по приложению. Ваше приложение может предпринимать действия в каждый момент этого жизненного цикла с помощью необязательных [lifecycle hooks](lifecycle-hooks.md), таких как `ngOnInit()`.

## Метаданные компонента

![Metadata](metadata.png)

Декоратор `@Component` идентифицирует класс, расположенный непосредственно под ним, как класс компонента и определяет его метаданные. В приведенном ниже примере кода видно, что `HeroListComponent` - это просто класс, без каких-либо специальных обозначений или синтаксиса Angular.
Он не является компонентом, пока вы не пометите его как компонент с помощью декоратора `@Component`.

Метаданные компонента указывают Angular, где взять основные строительные блоки, необходимые для создания и представления компонента и его вида. В частности, он связывает _шаблон_ с компонентом, либо непосредственно со встроенным кодом, либо по ссылке.

Вместе компонент и его шаблон описывают _вид_.

Помимо содержания шаблона или указания на него, метаданные `@Component` определяют, например, как на компонент можно ссылаться в HTML и какие службы ему требуются.

Вот пример основных метаданных для `HeroListComponent`.

```ts
@Component({
    selector: 'app-hero-list',
    templateUrl: './hero-list.component.html',
    providers: [HeroService],
})
export class HeroListComponent implements OnInit {
    /* . . . */
}
```

Этот пример показывает некоторые из наиболее полезных опций конфигурации `@Component`:

| Параметры конфигурации | Подробности                                                                                                                                                                                                                                                                                                    |
| :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `selector`             | CSS-селектор, который указывает Angular создать и вставить экземпляр этого компонента везде, где он найдет соответствующий тег в HTML шаблона. Например, если HTML приложения содержит `<app-hero-list></app-hero-list>`, то Angular вставляет экземпляр представления `HeroListComponent` между этими тегами. |
| `templateUrl`          | Относительный к модулю адрес HTML-шаблона этого компонента. В качестве альтернативы, вы можете указать HTML-шаблон в строке, как значение свойства `template`. Этот шаблон определяет _хостовое представление_ компонента.                                                                                     |
| `providers`            | Массив [providers](glossary.md#provider) для сервисов, которые требуются компоненту. В примере это указывает Angular, как предоставить экземпляр `HeroService`, который конструктор компонента использует для получения списка героев для отображения.                                                         |

## Шаблоны и представления

![Template](template.png)

Вы определяете вид компонента с помощью сопутствующего шаблона. Шаблон - это форма HTML, которая указывает Angular, как отобразить компонент.

Представления обычно организованы иерархически, что позволяет изменять или показывать и скрывать целые разделы пользовательского интерфейса или страницы как единое целое. Шаблон, непосредственно связанный с компонентом, определяет _хост-вид_ этого компонента.

Компонент также может определять _иерархию представлений_, которая содержит _вложенные представления_, размещенные в других компонентах.

![Component tree](component-tree.png)

Иерархия представлений может включать представления из компонентов одного и того же NgModule и из компонентов разных NgModules.

## Синтаксис шаблонов

Шаблон выглядит как обычный HTML, за исключением того, что он также содержит синтаксис Angular [template syntax](template-syntax.md), который изменяет HTML на основе логики вашего приложения и состояния данных приложения и DOM. Ваш шаблон может использовать _привязки данных_ для координации данных приложения и DOM, _пайпы_ для преобразования данных перед их отображением и _директивы_ для применения логики приложения к тому, что отображается.

Например, вот шаблон для компонента `HeroListComponent` учебника.

```html
<h2>Hero List</h2>

<p><em>Select a hero from the list to see details.</em></p>
<ul>
    <li *ngFor="let hero of heroes">
        <button type="button" (click)="selectHero(hero)">
            {{hero.name}}
        </button>
    </li>
</ul>

<app-hero-detail
    *ngIf="selectedHero"
    [hero]="selectedHero"
></app-hero-detail>
```

Этот шаблон использует типичные элементы HTML, такие как `<h2>` и `<p>`. Он также включает элементы синтаксиса шаблона Angular, `*ngFor`, `{{hero.name}}`, `(click)`, `[hero]` и `<app-hero-detail>`. Элементы синтаксиса шаблона указывают Angular, как вывести HTML на экран, используя программную логику и данные.

-   Директива `*ngFor` указывает Angular на итерацию списка.

-   `{{hero.name}}`, `(click)` и `[hero]` связывают данные программы с DOM и обратно, реагируя на ввод пользователя.

    Подробнее о [связывании данных](#data-binding) см. ниже.

-   Тег элемента `<app-hero-detail>` в примере представляет новый компонент, `HeroDetailComponent`.

    Компонент `HeroDetailComponent` определяет часть `hero-detail` визуализированной DOM-структуры, заданной компонентом `HeroListComponent`.

    Обратите внимание, как эти пользовательские компоненты смешиваются с родным HTML.

### Привязка данных

Без фреймворка вы были бы ответственны за введение значений данных в элементы управления HTML и превращение ответов пользователя в действия и обновления значений. Написание такой логики вручную утомительно, чревато ошибками и является кошмаром для чтения, что может подтвердить любой опытный программист на JavaScript.

Angular поддерживает _двустороннее связывание данных_, механизм для координации частей шаблона с частями компонента. Добавьте разметку привязки данных в HTML шаблона, чтобы указать Angular, как соединить обе стороны.

На следующей диаграмме показаны четыре формы разметки привязки данных. Каждая форма имеет направление: к DOM, из DOM или и то, и другое.

![Data Binding](databinding.png)

Этот пример из шаблона `HeroListComponent` использует три таких формы.

```html
<app-hero-detail [hero]="selectedHero"></app-hero-detail>
<button type="button" (click)="selectHero(hero)">
    {{hero.name}}
</button>
```

| Связывание данных                                                     | Подробнее                                                                                                                |
| :-------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------- |
| `[hero]` [property binding](property-binding.md)                      | Передает значение `selectedHero` из родительского `HeroListComponent` в свойство `hero` дочернего `HeroDetailComponent`. |
| `(click)` [event binding](user-input.md#binding-to-user-input-events) | Вызывает метод компонента `selectHero` при нажатии пользователем на имя героя.                                           |
| `{{hero.name}}` [interpolation](interpolation.md)                     | Отображает значение свойства `hero.name` компонента в элементе `<button>`.                                               |

Двусторонняя привязка данных (используется в основном в [шаблонно-ориентированных формах](forms.md)) объединяет привязку свойств и событий в одной нотации. Приведем пример из шаблона `HeroDetailComponent`, в котором используется двусторонняя привязка данных с помощью директивы `ngModel`.

```html
<input type="text" id="hero-name" [(ngModel)]="hero.name" />
```

При двустороннем связывании значение свойства данных поступает в поле ввода из компонента, как при связывании свойств. Изменения пользователя также возвращаются в компонент, сбрасывая свойство на последнее значение, как при привязке к событию.

Angular обрабатывает _все_ привязки данных один раз для каждого цикла событий JavaScript, начиная с корня дерева компонентов приложения и заканчивая всеми дочерними компонентами.

![Data Binding](component-databinding.png)

Привязка данных играет важную роль в коммуникации между шаблоном и его компонентом, а также важна для коммуникации между родительскими и дочерними компонентами.

![Parent/Child binding](parent-child-binding.png)

### Пайпы

Пайпы Angular позволяют объявлять преобразования отображения-значения в HTML шаблона. Класс с декоратором `@Pipe` определяет функцию, которая преобразует входные значения в выходные значения для отображения в представлении.

Angular определяет различные пайпы, такие как [date](https://angular.io/api/common/DatePipe) и [currency](https://angular.io/api/common/CurrencyPipe). Полный список см. в [Pipes API list](https://angular.io/api?type=pipe). Вы также можете определить новые пайпы.

Чтобы указать преобразование значений в шаблоне HTML, используйте оператор [пайп (`|`)](pipes.md).

```html
{{interpolated_value | pipe_name}}
```

Вы можете объединять пайпы в цепочку, отправляя вывод одной функции пайпа для преобразования другой функцией пайпа. Пайп также может принимать аргументы, которые управляют тем, как она выполняет преобразование.
Например, вы можете передать желаемый формат в функцию pipe `date`.

```html
<!-- Default format: output 'Jun 15, 2015'-->
<p>Today is {{today | date}}</p>

<!-- fullDate format: output 'Monday, June 15, 2015'-->
<p>The date is {{today | date:'fullDate'}}</p>

<!-- shortTime format: output '9:43 AM'-->
<p>The time is {{today | date:'shortTime'}}</p>
```

### Директивы

![Directives](directive.png)

Шаблоны Angular являются _динамическими_. Когда Angular рендерит их, он преобразует DOM в соответствии с инструкциями, заданными _директивами_. Директива - это класс с декоратором `@Directive()`.

Компонент технически является директивой. Однако компоненты настолько характерны и важны для приложений Angular, что Angular определяет декоратор `@Component()`, который расширяет декоратор `@Directive()` с функциями, ориентированными на шаблоны.

Помимо компонентов, есть еще два вида директив: _структурные_ и _атрибутивные_. Angular определяет ряд директив обоих типов, и вы можете определить свои собственные с помощью декоратора `@Directive()`.

Как и для компонентов, метаданные для директивы связывают декорированный класс с элементом `selector`, который используется для вставки в HTML. В шаблонах директивы обычно появляются в теге элемента как атрибуты, либо по имени, либо как цель присваивания или привязки.

#### Структурные директивы

_Структурные директивы_ изменяют макет путем добавления, удаления и замены элементов в DOM. В примере шаблона используются две встроенные структурные директивы для добавления логики приложения к тому, как отображается представление.

```html
<li *ngFor="let hero of heroes"></li>
<app-hero-detail *ngIf="selectedHero"></app-hero-detail>
```

| Директивы                                | Подробнее                                                                                                  |
| :--------------------------------------- | :--------------------------------------------------------------------------------------------------------- |
| [`*ngFor`](built-in-directives.md#ngFor) | _Итератив_, который указывает Angular создавать по одному `<li>` на каждого героя в списке `heroes`.       |
| [`*ngIf`](built-in-directives.md#ngIf)   | Безусловный, который включает компонент `HeroDetail` только в том случае, если выбранный герой существует. |

#### Директивы атрибутов

Директивы _Атрибутов_ изменяют внешний вид или поведение существующего элемента. В шаблонах они выглядят как обычные атрибуты HTML, отсюда и название.

Примером атрибутной директивы является директива `ngModel`, реализующая двустороннее связывание данных. `ngModel` изменяет поведение существующего элемента (обычно `<input>`), устанавливая его свойство display value и реагируя на события изменения.

```html
<input type="text" id="hero-name" [(ngModel)]="hero.name" />
```

Angular включает предопределенные директивы, которые изменяют:

-   Структуру макета, например [ngSwitch](built-in-directives.md#ngSwitch), и
-   Аспекты элементов и компонентов DOM, такие как [ngStyle](built-in-directives.md#ngstyle) и [ngClass](built-in-directives.md#ngClass).

!!!note ""

    Узнайте больше в руководствах [Attribute Directives](attribute-directives.md) и [Structural Directives](structural-directives.md).

## Ссылки

-   [Introduction to components and templates](https://angular.io/guide/architecture-components)
