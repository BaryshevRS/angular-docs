# Обзор элементов Angular

_Angular elements_ - это компоненты Angular, упакованные как _custom elements_ \(также называемые Web Components\), веб-стандарт для определения новых элементов HTML в независимости от фреймворка.

<div class="alert is-helpful">

Пример приложения, которое описывается на этой странице, см. в <live-example></live-example>.

</div>

[Пользовательские элементы](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) - это функция веб-платформы, которая в настоящее время поддерживается в Chrome, Edge \(на базе Chromium\), Firefox, Opera и Safari, и доступна в других браузерах через полифиллы \(см. [Поддержка браузеров](#browser-support)\). Пользовательский элемент расширяет HTML, позволяя вам определить тег, содержимое которого создается и контролируется кодом JavaScript.
Браузер поддерживает `CustomElementRegistry` определенных пользовательских элементов, который отображает инстанцируемый JavaScript класс на HTML тег.

Пакет `@angular/elements` экспортирует API `createCustomElement()`, который обеспечивает мост от интерфейса компонента Angular и функциональности обнаружения изменений к встроенному API DOM.

Преобразование компонента в пользовательский элемент делает всю необходимую инфраструктуру Angular доступной для браузера. Создание пользовательского элемента является простым и понятным и автоматически соединяет ваше представление, определяемое компонентом, с обнаружением изменений и привязкой данных, отображая функциональность Angular на соответствующие встроенные эквиваленты HTML.

<div class="alert is-helpful">

Мы работаем над созданием пользовательских элементов, которые могут быть использованы веб-приложениями, построенными на других фреймворках. Минимальная, самодостаточная версия фреймворка Angular внедряется в качестве сервиса для поддержки функций обнаружения изменений и привязки данных компонента.
Подробнее о направлении развития можно узнать из этой [видеопрезентации] (https://www.youtube.com/watch?v=Z1gLFPLVJjY&t=4s).

</div>

## Использование пользовательских элементов

Пользовательские элементы загружаются самостоятельно - они автоматически запускаются при добавлении в DOM и автоматически уничтожаются при удалении из DOM. После добавления пользовательского элемента в DOM любой страницы он выглядит и ведет себя как любой другой элемент HTML, и не требует специальных знаний терминов Angular или соглашений об использовании.

| | Подробности | |:--- |:--- |:--- |:---.

| Простой динамический контент в приложении Angular | Преобразование компонента в пользовательский элемент обеспечивает прямой путь к созданию динамического HTML-контента в приложении Angular. HTML-контент, который вы добавляете непосредственно в DOM в приложении Angular, обычно отображается без обработки Angular, если вы не определите _динамический компонент_, добавив свой собственный код для подключения HTML-тега к данным приложения и участия в обнаружении изменений. При использовании пользовательского элемента все эти действия выполняются автоматически. |

| Если у вас есть приложение с большим количеством контента | Если у вас есть приложение с большим количеством контента, например, приложение Angular, в котором представлена эта документация, пользовательские элементы позволят вам предоставить поставщикам контента сложную функциональность Angular, не требуя знания Angular. Например, руководство Angular, подобное этому, добавляется непосредственно в DOM средствами навигации Angular, но может включать специальные элементы типа `<code-snippet>`, которые выполняют сложные операции. Все, что вам нужно сообщить поставщику контента, - это синтаксис вашего пользовательского элемента. Им не нужно знать ничего об Angular, ни о структурах данных вашего компонента, ни о его реализации. |

### Как это работает

Используйте функцию `createCustomElement()` для преобразования компонента в класс, который может быть зарегистрирован в браузере как пользовательский элемент. После регистрации настроенного класса в реестре пользовательских элементов браузера, используйте новый элемент так же, как встроенный элемент HTML в содержимом, которое вы добавляете непосредственно в DOM:

<code-example format="html" language="html">

&lt;my-popup message="Используйте Angular!"&gt;&lt;/my-popup&gt;

</code-example>

Когда ваш пользовательский элемент размещается на странице, браузер создает экземпляр зарегистрированного класса и добавляет его в DOM. Содержание предоставляется шаблоном компонента, который использует синтаксис шаблонов Angular, и отображается с использованием данных компонента и DOM.
Входные свойства в компоненте соответствуют входным атрибутам для элемента.

<div class="lightbox">

<img alt="Custom element in browser" class="left" src="generated/images/guide/elements/customElement1.png">

</div>

## Преобразование компонентов в пользовательские элементы

Angular предоставляет функцию `createCustomElement()` для преобразования компонента Angular вместе с его зависимостями в пользовательский элемент. Функция собирает наблюдаемые свойства компонента, а также функциональные возможности Angular, необходимые браузеру для создания и уничтожения экземпляров, обнаружения и реагирования на изменения.

Процесс преобразования реализует интерфейс `NgElementConstructor` и создает класс-конструктор, настроенный на создание самозагружающегося экземпляра вашего компонента.

Используйте встроенную функцию [`customElements.define()`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry/define) для регистрации настроенного конструктора и связанного с ним тега пользовательского элемента в [`CustomElementRegistry`](https://developer.mozilla.org/docs/Web/API/CustomElementRegistry) браузера. Когда браузер встречает тег для зарегистрированного элемента, он использует конструктор для создания экземпляра пользовательского элемента.

<div class="lightbox">

<img alt="Transform a component to a custom element" class="left" src="generated/images/guide/elements/createElement.png">

</div>

<div class="alert is-important">

Избегайте использования [`@Component`](api/core/Component) [selector](api/core/Directive#selector) в качестве имени тега custom-элемента. Это может привести к неожиданному поведению, поскольку Angular создает два экземпляра компонента для одного элемента DOM:
один обычный компонент Angular и второй, использующий пользовательский элемент.

</div>

### Mapping

Пользовательский элемент _хостит_ компонент Angular, обеспечивая мост между данными и логикой, определенными в компоненте, и стандартными API DOM. Свойства и логика компонента отображаются непосредственно на атрибуты HTML и систему событий браузера.

-   API создания анализирует компонент в поисках входных свойств и определяет соответствующие атрибуты для пользовательского элемента.

    Он преобразует имена свойств, чтобы сделать их совместимыми с пользовательскими элементами, которые не различают регистр.

    В результирующих именах атрибутов используется строчный регистр, разделенный тире.

    Например, для компонента с `@Input('myInputProp') inputProp`, соответствующий пользовательский элемент определяет атрибут `my-input-prop`.

-   Выводы компонентов отправляются как HTML [Custom Events](https://developer.mozilla.org/docs/Web/API/CustomEvent), причем имя пользовательского события совпадает с именем вывода.

    Например, для компонента с `@Output() valueChanged = new EventEmitter()`, соответствующий пользовательский элемент отправляет события с именем "valueChanged", а выдаваемые данные сохраняются в свойстве `detail` события.

    Если вы указываете псевдоним, то используется это значение; например, `@Output('myClick') clicks = new EventEmitter<string>();` приводит к диспетчеризации событий с именем "myClick".

Для получения дополнительной информации см. документацию по веб-компоненту [Создание пользовательских событий](https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events#Creating_custom_events).

<a id="browser-support"></a>

## Поддержка браузером пользовательских элементов

Недавно разработанная функция [custom elements](https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements) Web Platform в настоящее время поддерживается в нескольких браузерах.

| Браузер | Поддержка пользовательских элементов | |:--- |:--- |:--- |

| Chrome | Поддерживается нативно. |

| Edge \(Chromium-based\) | Поддерживается нативно. |

| Firefox | Поддерживается нативно. |

| Opera | Поддерживается нативно. |

| Safari | Поддерживается нативно. |

Чтобы добавить пакет `@angular/elements` в свое рабочее пространство, выполните следующую команду:

<code-example format="shell" language="shell">

npm install @angular/elements --save

</code-example>

## Пример: Служба всплывающих окон

Раньше, когда вы хотели добавить компонент в приложение во время выполнения, вам нужно было определить _динамический компонент_, а затем загрузить его, прикрепить к элементу в DOM и подключить все зависимости, обнаружение изменений и обработку событий, как описано в [Dynamic Component Loader](guide/dynamic-component-loader).

Использование пользовательского элемента Angular делает этот процесс намного проще и прозрачнее, предоставляя всю инфраструктуру и каркас автоматически &mdash; все, что вам нужно сделать, это определить вид обработки событий, который вы хотите. \(Вам все равно придется исключить компонент из компиляции, если вы не собираетесь использовать его в своем приложении.\)

Следующий пример приложения Popup Service определяет компонент, который вы можете либо загрузить динамически, либо преобразовать в пользовательский элемент.

| Файлы | Детали | |:--- |:--- |:--- |

| `popup.component.ts` | Определяет простой всплывающий элемент, который отображает сообщение ввода, с некоторой анимацией и стилизацией. |

| `popup.service.ts` | Создает инжектируемый сервис, который предоставляет два различных способа вызова `PopupComponent`: как динамический компонент или как пользовательский элемент Обратите внимание, насколько больше настроек требуется для метода динамической загрузки. |

| | `app.module.ts` | Добавляет `PopupComponent` в список `declarations` модуля. |

| | `app.component.ts` | Определяет корневой компонент приложения, который использует `PopupService` для добавления всплывающего окна в DOM во время выполнения. Когда приложение запущено, конструктор корневого компонента преобразует `PopupComponent` в пользовательский элемент. |

Для сравнения в демонстрации показаны оба метода. Одна кнопка добавляет всплывающее окно с помощью метода динамической загрузки, а другая - с помощью пользовательского элемента.
Результат один и тот же, отличается только подготовка.

<code-tabs>
     <code-pane header="popup.component.ts" path="elements/src/app/popup.component.ts"></code-pane>
    <code-pane header="popup.service.ts" path="elements/src/app/popup.service.ts"></code-pane>
    <code-pane header="app.module.ts" path="elements/src/app/app.module.ts"></code-pane>
    <code-pane header="app.component.ts" path="elements/src/app/app.component.ts"></code-pane>
</code-tabs>

## Типы для пользовательских элементов

Общие API DOM, такие как `document.createElement()` или `document.querySelector()`, возвращают тип элемента, соответствующий указанным аргументам. Например, вызов `document.createElement('a')` возвращает `HTMLAnchorElement`, который, как известно TypeScript, имеет свойство `href`.

Аналогично, вызов `document.createElement('div')` возвращает `HTMLDivElement`, который, как известно TypeScript, не имеет свойства `href`.

При вызове неизвестных элементов, таких как пользовательское имя элемента \(`popup-element` в нашем примере\), методы возвращают общий тип, такой как `HTMLElement`, потому что TypeScript не может определить правильный тип возвращаемого элемента.

Пользовательские элементы, созданные с помощью Angular, расширяют `NgElement`\ (который, в свою очередь, расширяет `HTMLElement`\). Кроме того, эти пользовательские элементы будут иметь свойство для каждого входа соответствующего компонента.

Например, наш `popup-element` имеет свойство `message` типа `string`.

Есть несколько вариантов, если вы хотите получить правильные типы для ваших пользовательских элементов. Предположим, вы создаете пользовательский элемент `my-dialog` на основе следующего компонента:

<code-example format="typescript" language="typescript">

&commat;Component(&hellip;) class MyDialog {
&commat;Input() content: string;

}

</code-example>

Самый простой способ получить точную типизацию - привести возвращаемое значение соответствующих методов DOM к нужному типу. Для этого используйте типы `NgElement` и `WithProperties`\ (оба экспортируются из `@angular/elements`\):

<code-example format="typescript" language="typescript">

const aDialog = document.createElement('my-dialog') as NgElement &amp; WithProperties&lt;{content: string}&gt;; aDialog.content = 'Hello, world!';
aDialog.content = 123; // &lt;-- ERROR: TypeScript знает, что это должна быть строка.

aDialog.body = 'News'; // &lt;-- ERROR: TypeScript знает, что у `aDialog` нет свойства `body`.

</code-example>

Это хороший способ быстро получить возможности TypeScript, такие как проверка типов и поддержка автозаполнения, для вашего пользовательского элемента. Но он может стать громоздким, если он нужен в нескольких местах, потому что вам придется приводить возвращаемый тип в каждом случае.

Альтернативный способ, который требует определения типа каждого пользовательского элемента только один раз, заключается в дополнении `HTMLElementTagNameMap`, который TypeScript использует для вывода типа возвращаемого элемента на основе его имени тега\(для методов DOM, таких как `document.createElement()`, `document.querySelector()` и т.д.\):

<code-example format="typescript" language="typescript">

объявить глобальный { интерфейс HTMLElementTagNameMap {
'my-dialog': NgElement &amp; WithProperties&lt;{content: string}&gt;;

    'my-other-element': NgElement &amp; WithProperties&lt;{foo: 'bar'}&gt;;

    &hellip;

}

}

</code-example>

Теперь TypeScript может вывести правильный тип так же, как он это делает для встроенных элементов:

<code-example format="typescript" language="typescript">

document.createElement('div') //--&gt; HTMLDivElement (встроенный элемент) document.querySelector('foo') //--&gt; Element (неизвестный элемент)
document.createElement('my-dialog') //--&gt; NgElement &amp; WithProperties&lt;{content: string}&gt; (пользовательский элемент)

document.querySelector('my-other-element') //--&gt; NgElement &amp; WithProperties&lt;{foo: 'bar'}&gt; (пользовательский элемент)

</code-example>

<!-- links -->

<!-- external links -->

<!-- end links -->

@ просмотрено 2022-02-28
